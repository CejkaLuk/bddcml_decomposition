#!/usr/bin/env bash

# exit whenever a command fails
set -e

# enable recursive globbing
shopt -s globstar

### CONSTANTS
# Decomposers and which matrix format they produce:
# 0-2 -> Parallel Crout Method  (8, 16, 32) => UnitDiagIn_U
# 3-5 -> Iterative Crout Method (8, 16, 32) => UnitDiagIn_U
# 6   -> CuSolverDnXgetrfWrapper            => UnitDiagIn_L
# 7   -> MAGMAdgetrf_gpu (in BDDCML)

# Solvers and which matrix format they support:
# 0-4 -> Iterative Solver (8, 16, 32, 64, 128) => UnitDiagIn_U
# 5   -> CuBLAStrsmWrapper (U)                 => UnitDiagIn_U
# 6   -> CuBLAStrsmWrapper (L)                 => UnitDiagIn_L
# 7   -> CuSolverDnXgetrsWrapper               => UnitDiagIn_L
# 8   -> MAGMAdgetrs_gpu (in BDDCML)

# All Decomposers
declare -a DECOMPOSERS=("PCM_8" "PCM_16" "PCM_32" "ICM_8" "ICM_16" "ICM_32" "CuSolverDnXgetrf" "MAGMAdgetrf_gpu")
# All Solvers
declare -a SOLVERS=("IS_8" "IS_16" "IS_32" "IS_64" "IS_128" "CuBLAStrsm_U" "CuBLAStrsm_L" "CuSolverDnXgetrs" "MAGMAdgetrs_gpu")
# Repository root - assuming that the script was launched from 'benchmarks/poisson_on_cube'
REPO_ROOT=`readlink -f "../../"`
# Benchmarks directory
BENCHMARK_DIR="$REPO_ROOT/benchmarks/poisson_on_cube"
# Executables directory
EXECUTABLES_DIR="$BENCHMARK_DIR/executables"
# Benchmark executable
BENCHMARK_EXECUTABLE="$REPO_ROOT/examples/poisson_on_cube"
# Benchmark name
BENCHMARK_NAME="BDDCML Benchmark: poisson_on_cube"

## Helpful functions Part 1: Variable verification
# Assure existence of output directory
function assure_existence_of_output_dir() {
   local output_dir=$1
   local output_dir_abs_path=`readlink -f $output_dir`
   if [ ! -d "$output_dir_abs_path" ]; then
      >&2 echo "-> Warning: Output directory not found: '$output_dir_abs_path'. Creating..."
      mkdir $output_dir_abs_path
   fi
   echo "$output_dir_abs_path"
}

# Check validity of loops
function check_loops() {
   local loops=$1
   if [[ $loops -le 0 ]]; then
      >&2 echo "-!> Error: Cannot run benchmark for '$loops' loops. Please choose a number greater than 0. Exiting..."
      exit 1
   fi
   echo "$loops"
}

# Check validity of elements per sub edge
function check_el_per_sub_edge() {
   local el_per_sub_edge=$1
   if [[ $el_per_sub_edge -le 0 ]]; then
      >&2 echo "-!> Error: Cannot run benchmark for '$el_per_sub_edge' elements per sub edge. Please choose a number greater than 0. Exiting..."
      exit 1
   fi
   echo "$el_per_sub_edge"
}

function delete_existing_log_file() {
   local make_clean_all_file=$1
   if [[ -f "$make_clean_all_file" ]]; then
      echo "WARNING: deleting an existing log file $make_clean_all_file"
      rm -f "$make_clean_all_file"
   fi
}

function print_time() {
   local secs=$1
   local ELAPSED="Elapsed: $(($secs / 3600))hrs $((($secs / 60) % 60))min $(($secs % 60))sec"
   echo -e "$ELAPSED"
}

# Global variables
OUTPUT_DIR="log-files"
LOOPS=10
START_EL_PER_SUB_EDGE=5
END_EL_PER_SUB_EDGE=40
INCREMENT_EL_PER_SUB_EDGE=5

# Script usage
function print_help() {
	echo "Please use the following input parameters:"
   echo "-s=<start_el_per_sub_edge>         |  --start-el-per-sub-edge=<start_el_per_sub_edge>     [Optional] Starting number of elements per sub edge. Default value is '$START_EL_PER_SUB_EDGE'. The benchmark runs increments of $INCREMENT_EL_PER_SUB_EDGE: from $START_EL_PER_SUB_EDGE to $END_EL_PER_SUB_EDGE."
   echo "-e=<end_el_per_sub_edge>           |  --end-el-per-sub-edge=<end_el_per_sub_edge>         [Optional] Ending number of elements per sub edge. Default value is '$END_EL_PER_SUB_EDGE'. The benchmark runs increments of $INCREMENT_EL_PER_SUB_EDGE: from $START_EL_PER_SUB_EDGE to $END_EL_PER_SUB_EDGE."
   echo "-i=<increment_el_per_sub_edge>     |  --incr-el-per-sub-edge=<increment_el_per_sub_edge>  [Optional] Number of elements per sub edge to increment by. Default value is '$INCREMENT_EL_PER_SUB_EDGE'. The benchmark runs increments of $INCREMENT_EL_PER_SUB_EDGE: from $START_EL_PER_SUB_EDGE to $END_EL_PER_SUB_EDGE."
   echo "-l=<loops>                         |  --loops=<loops>                                     [Optional] Number of loops to run the 'poisson_on_cube' executable for - for result averaging. Default is '$LOOPS'"
	echo "-o=<dir>                           |  --output-dir=<dir>                                  [Optional] Output directory where the log files will be stored. Default is '$OUTPUT_DIR' and it is created in the current dir if it doesn't exist."
}

# Too many input parameters supplied
if [ $# -gt 5 ]
then
	echo "Too many input parameters supplied."
	print_help
	exit 1
fi

for i in "$@"; do
	case $1 in
      -s=*|--start-el-per-sub-edge=*)
			START_EL_PER_SUB_EDGE="${i#*=}"
			shift # past argument=value
			;;
      -e=*|--end-el-per-sub-edge=*)
         END_EL_PER_SUB_EDGE="${i#*=}"
         shift # past argument=value
         ;;
      -i=*|--incr-el-per-sub-edge=*)
         INCREMENT_EL_PER_SUB_EDGE="${i#*=}"
         shift # past argument=value
         ;;
		-l=*|--loops=*)
			LOOPS="${i#*=}"
			shift # past argument=value
			;;
      -o=*|--output-dir=*)
         OUTPUT_DIR="${i#*=}"
         shift # past argument=value
         ;;
      -*|--*)
         echo "Input parameter '$1' is not supported."
         print_help
         exit 1
         ;;
      *)
         ;;
	esac
done

# Assure the existence of the output directory
OUTPUT_DIR=$(assure_existence_of_output_dir "$OUTPUT_DIR")

# Check the if the number of loops is valid
LOOPS=$(check_loops "$LOOPS")

# Check the starting num. of elements per sub edge
START_EL_PER_SUB_EDGE=$(check_el_per_sub_edge "$START_EL_PER_SUB_EDGE")

# Check the ending num. of elements per sub edge
END_EL_PER_SUB_EDGE=$(check_el_per_sub_edge "$END_EL_PER_SUB_EDGE")

### BENCHMARK
echo -e "======================================== [ START ] $BENCHMARK_NAME\n"
echo "===== Parameters"
echo "LOOPS                         = $LOOPS"
echo "OUTPUT DIRECTORY              = $OUTPUT_DIR"
echo "STARTING EL PER SUB EDGE      = $START_EL_PER_SUB_EDGE"
echo "ENDING EL PER SUB EDGE        = $END_EL_PER_SUB_EDGE"
echo "INCREMENT EL PER SUB EDGE BY  = $INCREMENT_EL_PER_SUB_EDGE"
echo "DECOMPOSERS                   = ${DECOMPOSERS[@]}"
echo "SOLVERS                       = ${SOLVERS[@]}"
echo -e "=====\n"

# Check that the executables dir exists and is not empty
if [[ -d "$EXECUTABLES_DIR" ]]; then
   if [ $(ls -A "$EXECUTABLES_DIR" | wc -l) -ne 0 ]; then
      echo "-> Executables directory found: $EXECUTABLES_DIR"
   else
      echo "-!> Executables directory found BUT IT IS EMPTY: $EXECUTABLES_DIR"
      echo "-!> Use the 'prepare_poisson_on_cube_benchmark' script to load it with executables for the benchmark."
      echo "-!> Exiting..."
      exit 1
   fi
else
   echo "-!> Executables directory NOT FOUND: $EXECUTABLES_DIR"
   echo "-!> Create it and use the 'prepare_poisson_on_cube_benchmark' script to load it with executables for the benchmark."
   echo "-!> Exiting..."
   exit 1
fi

## BENCHMARK - DECOMPOSERS
echo -e "\n==================== [ START ] $BENCHMARK_NAME - Decomposers\n"

# Begin timer
SECONDS=0

num_decomposers=${#DECOMPOSERS[@]}
for (( decomposer = 0; decomposer < $num_decomposers; decomposer++ ))
do
   $BENCHMARK_DIR/run_poisson_on_cube_for "DECOMPOSERS" $decomposer $START_EL_PER_SUB_EDGE $END_EL_PER_SUB_EDGE $INCREMENT_EL_PER_SUB_EDGE $LOOPS $OUTPUT_DIR
done

echo -e "==================== [ FINISH ] $BENCHMARK_NAME - Decomposers\n"
# End timer
print_time $SECONDS

## BENCHMARK - SOLVERS
echo -e "\n==================== [ START ] $BENCHMARK_NAME - Solvers\n"

# Begin timer
SECONDS=0

num_solvers=${#SOLVERS[@]}
for (( solver = 0; solver < $num_solvers; solver++ ))
do
   $BENCHMARK_DIR/run_poisson_on_cube_for "SOLVERS" $solver $START_EL_PER_SUB_EDGE $END_EL_PER_SUB_EDGE $INCREMENT_EL_PER_SUB_EDGE $LOOPS $OUTPUT_DIR
done

echo -e "==================== [ FINISH ] $BENCHMARK_NAME - Solvers\n"
# End timer
print_time $SECONDS

echo -e "\n\n======================================== [ FINISH ] $BENCHMARK_NAME"
